<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode-4-寻找两个有序数组的中位数</title>
    <url>/LeetCode/median-of-two-sorted-arrays/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(\log(m + n))$。</p>
<a id="more"></a>

<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>

<h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为是找两个有序数组的中位数，首先想到的就是合并两个数组再找中位数，而合并两个有序数组又是归并排序的一部分，自然而然就想到修改归并排序中的 merge 方法来进行解题。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] all = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + len2];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[p1] &lt;= nums2[p2]) &#123;</span><br><span class="line">                all[k++] = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                all[k++] = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; len1) &#123;</span><br><span class="line">            all[k++] = nums1[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt; len2) &#123;</span><br><span class="line">            all[k++] = nums2[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = all.length;</span><br><span class="line">        <span class="keyword">if</span> (len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> all[len / <span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (all[len / <span class="number">2</span>] + all[len / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：遍历全部数组 $O(m+n)$</p>
<p>空间复杂度：开辟了一个数组，保存合并后的两个数组 $O(m+n)$</p>
<h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>仔细思考，其实并没有必要归并两个数组，找到中位数即可终止循环，可以省去中位数之后对数组访问以及比较的开销。假设两个数组总长度为 len，对于奇数来说，找到第 $\lceil len/2 \rceil$ 个数即可停止，需要循环 $\lfloor len/2 \rfloor+1$ 次；对于偶数来说，需要找到第 $len/2$ 和第 $len/2+1$ 个数字，需要循环 $len/2+1$ 次。综合奇偶的情况，循环的次数是相同的，只是对于偶数来说，需要用一个变量来存储上一次循环中的所访问的元素，最后根据奇偶情况返回结果。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> len = len1 + len2;</span><br><span class="line">        <span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            left = right;</span><br><span class="line">            <span class="comment">// 两个数组都未耗尽</span></span><br><span class="line">            <span class="keyword">if</span> (p1 != len1 &amp;&amp; p2 != len2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                    right = nums1[p1++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = nums2[p2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1 == len1) &#123; <span class="comment">// 左数组耗尽</span></span><br><span class="line">                right = nums2[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右数组耗尽</span></span><br><span class="line">                right = nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((len &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123; <span class="comment">// 和 1 做位运算，判断奇偶</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：遍历一半长度的数组 O(m+n)</p>
<p>空间复杂度：只保存部分常量 O(1)</p>
<h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>以上两种解法都还没有达到题目的要求，时间复杂度要达到 $O(\log(m+n))$ 的要求，通常来说需要用到二分法，需要思考的即是在此处如何使用二分法。以奇数为例，要找中位数，假设第 $k$ 小的数字是中位数，两个数组通过比较两个数组处于 $k/2$ 位置元素的大小，即可将较小元素及该数组内之前所有 $k/2$ 个元素都舍弃，这些元素必然不会处在中位数的位置。分析如下：</p>
<p>对于<code>A[0]</code>，<code>A[1]</code>…，<code>A[k/2]</code>，…；<code>B[0]</code>，<code>B[1]</code>…，<code>B[k/2]</code>，…，若 <code>A[k/2]</code> &lt; <code>B[k/2]</code>，则 <code>A[k/2]</code> 最大只能是第 $k-1$ 小的数，当 $A[k/2] &gt; B[k/2-1]$ 时成立。</p>
<p>下面通过图例展示下解法的过程。假设两个数组分别是 <code>A = [1, 3, 5, 7]</code>，<code>B = [1, 2, 3, 4, 5, 6, 7, 8, 9]</code></p>
<p>两个数组元素个数为 13，中位数为第 7 个元素，两个数组的第 $k/2$ 个元素分别是 <code>A[2]</code>， <code>B[2]</code>，<code>B[2] &lt; A[2]</code>，即 <code>A[2]</code> 及其之前的元素全部舍弃。</p>


<p>橙色部分表示已经去掉的数字，第一次比较会排除 <code>B[0]、B[1]、B[2]</code> 三个元素，在剩下的元素中，只需要找到第 $k=7-3=4$ 小的数即可，再继续向后比较第 $k/2=2$ 个元素。</p>


<p>这次比较将<code>A[0]、A[1]</code>元素去除。更新 $k=4-2=2$，向后比较第 $k/2=1$ 个元素</p>


<p>这次比较将 <code>B[3]</code> 元素去除。更新 <code>k=2-1=1</code>，表示在剩余的元素中取第 1 小的元素，只需比较两个数组剩余元素的第一个元素的大小即可，较小的元素就是中位数。</p>



<p>存在一种特殊情况，即 $k/2$ 大于某个数组的长度，如图，<code>k/2 &gt; A.length</code>，则指针指向数组的末尾，使用数组末尾的元素进行比较。</p>


<p>更新 $k=6-2=4$ ，此时上边的数组已经没有剩余元素了，可以直接返回<code>B[3]</code>作为结果。</p>


<p>实际上<code>更新的 k 值 = 原 k 值 - 上次丢弃元素的数量</code>，丢弃的元素数量要根据具体情况进行判断。</p>
<p>我本身实现了一种非递归的方法，但是由于需要在循环内以及循环外对各个边界情况以及奇偶进行判断，造成代码臃肿不够简洁。LeetCode 题解中有一个人用了递归的方法进行解决，将奇数和偶数的情况进行合并计算，递归的终止条件有两个：某一数组无剩余元素，返回另一数组剩余的第一个元素； <code>k == 1</code>，返回两个数组中较小的元素。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> m = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">        <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + getKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> p1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> p2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = nums1.length - p1;</span><br><span class="line">        <span class="keyword">int</span> len2 = nums2.length - p2;</span><br><span class="line">        <span class="comment">// trick，让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 nums1</span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums2, p2, nums1, p1, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums2[p2 + k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(nums1[p1], nums2[p2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = p1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = p2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, p1, nums2, j + <span class="number">1</span>, k - (j - p2 + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, nums2, p2, k - (i - p1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(\log (m+n))$</p>
<p>空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，空间复杂度为 $O(1)$</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己思考的时候只想到了前两种解法，期间还使用快排的变式快速选择写过一个解法，然而翻书的时候才发现，快速选择的时间复杂度是 $O(N)$ ，况且对于已经排好序的两个数组来说，并没有前两种解法的效率高，看书的时候就记住了一个找第  <code>k</code> 大的元素用快速选择，生搬硬套。自己没有想到第三种解法，看了别人的题解才理解，说明对二分法的使用不太敏感。还是做题不够，认识不够，思考不够。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>高级算法第一次练习</title>
    <url>/advanced-algorithm/practice-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次高级算法课的课堂练习题解题思路及实现总结。</p>
<a id="more"></a>

<h2 id="1-按数值个数排序"><a href="#1-按数值个数排序" class="headerlink" title="1. 按数值个数排序"></a>1. 按数值个数排序</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Given an array of integers, sort the array according to frequency of elements. For example, if the input array is {2, 3, 2, 4, 5, 12, 2, 3, 3, 3, 12}, then modify the array to {3, 3, 3, 3, 2, 2, 2, 12, 12, 4, 5}. If frequencies of two elements are same, print them in increasing order.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以将每个数字本身和它的出现次数构造为一个整体元素。这些元素排序的规则为，先按出现次数从大到小排序，若出现次数相同，则按照数字大小从小到大排序。</p>
<p>时间复杂度 $O(nlogn)$</p>
<p>空间复杂度 $O(n)$</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key 是 num，value 是 freq</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = map.get(nums[i]);</span><br><span class="line">            map.put(nums[i], ++v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.sort((o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.f &lt; o2.f) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.f &gt; o2.f) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.v - o2.v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (Node n : nodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.f; i++) &#123;</span><br><span class="line">            sb.append(n.v + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.f = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-最小交换次数"><a href="#2-最小交换次数" class="headerlink" title="2. 最小交换次数"></a>2. 最小交换次数</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>Given an array of N distinct elementsA[ ], find the minimum number of swaps required to sort the array.Your are required to complete the function which returns an integer denoting the minimum number of swaps, required to sort the array.</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>使用一个复制 A[] 的辅助数组，将辅助数组排序，得到原数组中每个元素在排序后应该在的位置，<strong>使用 Map 保存每个元素和其最终位置的映射</strong>。从前向后遍历原数组，与排序好的辅助数组比较。假设辅助数组为 aux，当前位置为 i</p>
<ul>
<li>若 A[i] = aux[i]，则表示当前元素在排序后的最终位置上，则检查下一个元素</li>
<li>若 A[i] != aux[i]，将该元素和它正确位置的元素进行交换，swap(i, map.get(A[i]))，直到 A[i] = aux[i]</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">miniSwap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] aux = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    Arrays.sort(aux);</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aux.length; i++) &#123;</span><br><span class="line">        map.put(aux[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == aux[i]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, map.get(nums[i]));</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-倒置个数"><a href="#3-倒置个数" class="headerlink" title="3. 倒置个数"></a>3. 倒置个数</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>有一个由 N 个实数构成的数组，如果一对元素 A[i] 和 A[j] 是倒序的，即 i &lt; j 但是 A[i] &gt; A[j] 则称它们是一个倒置，设计一个计算该数组中所有倒置数量的算法。要求算法复杂度为 $O(nlogn)$</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这是一道典型的归并排序的应用题，假设一个左右被排序好的两个部分，aux[lo, … , mid] 和 aux[mid+1, … , hi]，思考如何在归并两个部分的时候进行倒置的计算。</p>
<p>指针 i 指向 aux[lo, … , mid] 中的元素</p>
<p>指针 j 指向 aux[mid+1, … , hi] 中的元素</p>
<p>对两个部分按照正常归并排序进行排序，需要注意的是计算倒置的时机：</p>
<ul>
<li>当 aux[i] &gt; aux[j] 时，形成了倒置，且 aux[i, … , mid] 之间的所有数和 aux[j] 都形成了倒置对，此时倒置个数为 <strong>mid - i + 1</strong></li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">    <span class="keyword">return</span> sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count += sort(a, lo, mid);</span><br><span class="line">    count += sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="keyword">return</span> count + merge(a, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[j] &lt; aux[i]) &#123;</span><br><span class="line">            count += mid - i + <span class="number">1</span>;</span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-相对排序"><a href="#4-相对排序" class="headerlink" title="4. 相对排序"></a>4. 相对排序</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>Given two array A1[] and A2[], sort A1 in such a way that the relative order among the elements will be same as those in A2. For the elements not present in A2. Append them at last in sorted order. It is also given that the number of elements in A2[] are smaller than or equal to number of elements in A1[] and A2[] has all distinct elements.</p>
<p>Input:A1[] = {2, 1, 2, 5, 7, 1, 9, 3, 6, 8, 8} A2[] = {2, 1, 8, 3} Output: A1[] = {2, 2, 1, 1, 8, 8, 3, 5, 6, 7, 9}</p>
<p>Since 2 is present first in A2[], all occurrences of 2s should appear first in A[], then all occurrences 1s as 1 comes after 2 in A[]. Next all occurrences of 8 and then all occurrences of 3. Finally we print all those elements of A1[] that are not present in A2[]</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>和第一题思路一样，同样是按照给定规则给数组排序，将数组中的数、数的出现次数以及在 A2 中的出现顺序作为一个元素，对这些元素进行排序，最后输出结果。</p>
<p>排序规则为：</p>
<ul>
<li>先按 A2 中的出现先后顺序从小到大排序。若 A2[i] = n，则 n 的 order 为 i。若数字没出现在 A2[] 中，则 order 为 Integer.MAX_VALUE。</li>
<li>再按数字大小从小到大排序。</li>
</ul>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] orders)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; orderMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; orders.length; i++) &#123;</span><br><span class="line">        orderMap.put(orders[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = map.get(nums[i]);</span><br><span class="line">            map.put(nums[i], ++v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> order = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (orderMap.containsKey(entry.getKey())) &#123;</span><br><span class="line">            order = orderMap.get(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> Node(entry.getKey(), entry.getValue(), order));</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.sort((o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.o &gt; o2.o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.o &lt; o2.o) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.v - o2.v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (Node n : nodes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.f; i++) &#123;</span><br><span class="line">            sb.append(n.v + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> f;</span><br><span class="line">    <span class="keyword">int</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> f, <span class="keyword">int</span> o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.f = f;</span><br><span class="line">        <span class="keyword">this</span>.o = o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>advanced-algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
