<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高级算法第一次练习]]></title>
    <url>%2Fadvanced-algorithm%2Fpractice-1%2F</url>
    <content type="text"><![CDATA[第一次高级算法课的课堂练习题解题思路及实现总结。 1. 按数值个数排序描述Given an array of integers, sort the array according to frequency of elements. For example, if the input array is {2, 3, 2, 4, 5, 12, 2, 3, 3, 3, 12}, then modify the array to {3, 3, 3, 3, 2, 2, 2, 12, 12, 4, 5}. If frequencies of two elements are same, print them in increasing order. 思路可以将每个数字本身和它的出现次数构造为一个整体元素。这些元素排序的规则为，先按出现次数从大到小排序，若出现次数相同，则按照数字大小从小到大排序。 时间复杂度 $O(nlogn)$ 空间复杂度 $O(n)$ 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static String sort(int[] nums) &#123; // key 是 num，value 是 freq HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(nums[i])) &#123; int v = map.get(nums[i]); map.put(nums[i], ++v); &#125; else &#123; map.put(nums[i], 1); &#125; &#125; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; nodes.add(new Node(entry.getKey(), entry.getValue())); &#125; nodes.sort((o1, o2) -&gt; &#123; if (o1.f &lt; o2.f) &#123; return 1; &#125; else if (o1.f &gt; o2.f) &#123; return -1; &#125; else &#123; return o1.v - o2.v; &#125; &#125;); StringBuilder sb = new StringBuilder(); for (Node n : nodes) &#123; for (int i = 0; i &lt; n.f; i++) &#123; sb.append(n.v + " "); &#125; &#125; sb.deleteCharAt(sb.length() - 1); return sb.toString();&#125;static class Node &#123; int v; int f; public Node(int v, int f) &#123; this.v = v; this.f = f; &#125;&#125; 2. 最小交换次数描述Given an array of N distinct elementsA[ ], find the minimum number of swaps required to sort the array.Your are required to complete the function which returns an integer denoting the minimum number of swaps, required to sort the array. 思路使用一个复制 A[] 的辅助数组，将辅助数组排序，得到原数组中每个元素在排序后应该在的位置，使用 Map 保存每个元素和其最终位置的映射。从前向后遍历原数组，与排序好的辅助数组比较。假设辅助数组为 aux，当前位置为 i 若 A[i] = aux[i]，则表示当前元素在排序后的最终位置上，则检查下一个元素 若 A[i] != aux[i]，将该元素和它正确位置的元素进行交换，swap(i, map.get(A[i]))，直到 A[i] = aux[i] 实现12345678910111213141516171819private static int miniSwap(int[] nums) &#123; int[] aux = Arrays.copyOf(nums, nums.length); Arrays.sort(aux); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; aux.length; i++) &#123; map.put(aux[i], i); &#125; int count = 0; for (int i = 0; i &lt; nums.length; ) &#123; if (nums[i] == aux[i]) &#123; i++; continue; &#125; swap(nums, i, map.get(nums[i])); count++; &#125; return count;&#125; 3. 倒置个数描述有一个由 N 个实数构成的数组，如果一对元素 A[i] 和 A[j] 是倒序的，即 i &lt; j 但是 A[i] &gt; A[j] 则称它们是一个倒置，设计一个计算该数组中所有倒置数量的算法。要求算法复杂度为 $O(nlogn)$ 思路这是一道典型的归并排序的应用题，假设一个左右被排序好的两个部分，aux[lo, … , mid] 和 aux[mid+1, … , hi]，思考如何在归并两个部分的时候进行倒置的计算。 指针 i 指向 aux[lo, … , mid] 中的元素 指针 j 指向 aux[mid+1, … , hi] 中的元素 对两个部分按照正常归并排序进行排序，需要注意的是计算倒置的时机： 当 aux[i] &gt; aux[j] 时，形成了倒置，且 aux[i, … , mid] 之间的所有数和 aux[j] 都形成了倒置对，此时倒置个数为 mid - i + 1 实现12345678910111213141516171819202122232425262728293031323334353637383940private static int[] aux;public static int sort(int[] a) &#123; aux = new int[a.length]; return sort(a, 0, a.length - 1);&#125;private static int sort(int[] a, int lo, int hi) &#123; if (hi &lt;= lo) &#123; return 0; &#125; int mid = lo + (hi - lo) / 2; int count = 0; count += sort(a, lo, mid); count += sort(a, mid + 1, hi); return count + merge(a, lo, mid, hi);&#125;private static int merge(int[] a, int lo, int mid, int hi) &#123; for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; int count = 0; int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) &#123; a[k] = aux[j++]; &#125; else if (j &gt; hi) &#123; a[k] = aux[i++]; &#125; else if (aux[j] &lt; aux[i]) &#123; count += mid - i + 1; a[k] = aux[j++]; &#125; else &#123; a[k] = aux[i++]; &#125; &#125; return count;&#125; 4. 相对排序描述Given two array A1[] and A2[], sort A1 in such a way that the relative order among the elements will be same as those in A2. For the elements not present in A2. Append them at last in sorted order. It is also given that the number of elements in A2[] are smaller than or equal to number of elements in A1[] and A2[] has all distinct elements. Input:A1[] = {2, 1, 2, 5, 7, 1, 9, 3, 6, 8, 8} A2[] = {2, 1, 8, 3} Output: A1[] = {2, 2, 1, 1, 8, 8, 3, 5, 6, 7, 9} Since 2 is present first in A2[], all occurrences of 2s should appear first in A[], then all occurrences 1s as 1 comes after 2 in A[]. Next all occurrences of 8 and then all occurrences of 3. Finally we print all those elements of A1[] that are not present in A2[] 思路和第一题思路一样，同样是按照给定规则给数组排序，将数组中的数、数的出现次数以及在 A2 中的出现顺序作为一个元素，对这些元素进行排序，最后输出结果。 排序规则为： 先按 A2 中的出现先后顺序从小到大排序。若 A2[i] = n，则 n 的 order 为 i。若数字没出现在 A2[] 中，则 order 为 Integer.MAX_VALUE。 再按数字大小从小到大排序。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private static String sort(int[] nums, int[] orders) &#123; Map&lt;Integer, Integer&gt; orderMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; orders.length; i++) &#123; orderMap.put(orders[i], i); &#125; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.containsKey(nums[i])) &#123; int v = map.get(nums[i]); map.put(nums[i], ++v); &#125; else &#123; map.put(nums[i], 1); &#125; &#125; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; int order = Integer.MAX_VALUE; if (orderMap.containsKey(entry.getKey())) &#123; order = orderMap.get(entry.getKey()); &#125; nodes.add(new Node(entry.getKey(), entry.getValue(), order)); &#125; nodes.sort((o1, o2) -&gt; &#123; if (o1.o &gt; o2.o) &#123; return 1; &#125; else if (o1.o &lt; o2.o) &#123; return -1; &#125; else &#123; return o1.v - o2.v; &#125; &#125;); StringBuilder sb = new StringBuilder(); for (Node n : nodes) &#123; for (int i = 0; i &lt; n.f; i++) &#123; sb.append(n.v + " "); &#125; &#125; sb.deleteCharAt(sb.length() - 1); return sb.toString();&#125;static class Node &#123; int v; int f; int o; public Node(int v, int f, int o) &#123; this.v = v; this.f = f; this.o = o; &#125;&#125;]]></content>
      <categories>
        <category>advanced-algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-4-寻找两个有序数组的中位数]]></title>
    <url>%2FLeetCode%2Fmedian-of-two-sorted-arrays%2F</url>
    <content type="text"><![CDATA[题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(\log(m + n))$。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 123nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2: 123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 解法一思路因为是找两个有序数组的中位数，首先想到的就是合并两个数组再找中位数，而合并两个有序数组又是归并排序的一部分，自然而然就想到修改归并排序中的 merge 方法来进行解题。 代码12345678910111213141516171819202122232425262728293031class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int p1 = 0; int p2 = 0; int len1 = nums1.length; int len2 = nums2.length; int[] all = new int[len1 + len2]; int k = 0; while (p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123; if (nums1[p1] &lt;= nums2[p2]) &#123; all[k++] = nums1[p1++]; &#125; else &#123; all[k++] = nums2[p2++]; &#125; &#125; while (p1 &lt; len1) &#123; all[k++] = nums1[p1++]; &#125; while (p2 &lt; len2) &#123; all[k++] = nums2[p2++]; &#125; int len = all.length; if (len % 2 != 0) &#123; return all[len / 2]; &#125; else &#123; return (all[len / 2] + all[len / 2 - 1]) / 2.0; &#125; &#125;&#125; 时间复杂度：遍历全部数组 $O(m+n)$ 空间复杂度：开辟了一个数组，保存合并后的两个数组 $O(m+n)$ 解法二思路仔细思考，其实并没有必要归并两个数组，找到中位数即可终止循环，可以省去中位数之后对数组访问以及比较的开销。假设两个数组总长度为 len，对于奇数来说，找到第 $\lceil len/2 \rceil$ 个数即可停止，需要循环 $\lfloor len/2 \rfloor+1$ 次；对于偶数来说，需要找到第 $len/2$ 和第 $len/2+1$ 个数字，需要循环 $len/2+1$ 次。综合奇偶的情况，循环的次数是相同的，只是对于偶数来说，需要用一个变量来存储上一次循环中的所访问的元素，最后根据奇偶情况返回结果。 代码1234567891011121314151617181920212223242526272829303132class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int p1 = 0; int p2 = 0; int len1 = nums1.length; int len2 = nums2.length; int len = len1 + len2; int left = -1; int right = -1; for (int i = 0; i &lt;= len / 2; i++) &#123; left = right; // 两个数组都未耗尽 if (p1 != len1 &amp;&amp; p2 != len2) &#123; if (nums1[p1] &lt; nums2[p2]) &#123; right = nums1[p1++]; &#125; else &#123; right = nums2[p2++]; &#125; &#125; else if (p1 == len1) &#123; // 左数组耗尽 right = nums2[p2++]; &#125; else &#123; // 右数组耗尽 right = nums1[p1++]; &#125; &#125; if ((len &amp; 1) != 0) &#123; // 和 1 做位运算，判断奇偶 return right; &#125; else &#123; return (left + right) / 2.0; &#125; &#125;&#125; 时间复杂度：遍历一半长度的数组 O(m+n) 空间复杂度：只保存部分常量 O(1) 解法三思路以上两种解法都还没有达到题目的要求，时间复杂度要达到 $O(\log(m+n))$ 的要求，通常来说需要用到二分法，需要思考的即是在此处如何使用二分法。以奇数为例，要找中位数，假设第 $k$ 小的数字是中位数，两个数组通过比较两个数组处于 $k/2$ 位置元素的大小，即可将较小元素及该数组内之前所有 $k/2$ 个元素都舍弃，这些元素必然不会处在中位数的位置。分析如下： 对于A[0]，A[1]…，A[k/2]，…；B[0]，B[1]…，B[k/2]，…，若 A[k/2] &lt; B[k/2]，则 A[k/2] 最大只能是第 $k-1$ 小的数，当 $A[k/2] &gt; B[k/2-1]$ 时成立。 下面通过图例展示下解法的过程。假设两个数组分别是 A = [1, 3, 5, 7]，B = [1, 2, 3, 4, 5, 6, 7, 8, 9] 两个数组元素个数为 13，中位数为第 7 个元素，两个数组的第 $k/2$ 个元素分别是 A[2]， B[2]，B[2] &lt; A[2]，即 A[2] 及其之前的元素全部舍弃。 橙色部分表示已经去掉的数字，第一次比较会排除 B[0]、B[1]、B[2] 三个元素，在剩下的元素中，只需要找到第 $k=7-3=4$ 小的数即可，再继续向后比较第 $k/2=2$ 个元素。 这次比较将A[0]、A[1]元素去除。更新 $k=4-2=2$，向后比较第 $k/2=1$ 个元素 这次比较将 B[3] 元素去除。更新 k=2-1=1，表示在剩余的元素中取第 1 小的元素，只需比较两个数组剩余元素的第一个元素的大小即可，较小的元素就是中位数。 存在一种特殊情况，即 $k/2$ 大于某个数组的长度，如图，k/2 &gt; A.length，则指针指向数组的末尾，使用数组末尾的元素进行比较。 更新 $k=6-2=4$ ，此时上边的数组已经没有剩余元素了，可以直接返回B[3]作为结果。 实际上更新的 k 值 = 原 k 值 - 上次丢弃元素的数量，丢弃的元素数量要根据具体情况进行判断。 我本身实现了一种非递归的方法，但是由于需要在循环内以及循环外对各个边界情况以及奇偶进行判断，造成代码臃肿不够简洁。LeetCode 题解中有一个人用了递归的方法进行解决，将奇数和偶数的情况进行合并计算，递归的终止条件有两个：某一数组无剩余元素，返回另一数组剩余的第一个元素； k == 1，返回两个数组中较小的元素。 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int n = nums1.length; int m = nums2.length; int left = (n + m + 1) / 2; int right = (n + m + 2) / 2; // 将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。 return (getKth(nums1, 0, nums2, 0, left) + getKth(nums1, 0, nums2, 0, right)) * 0.5; &#125; private int getKth(int[] nums1, int p1, int[] nums2, int p2, int k) &#123; int len1 = nums1.length - p1; int len2 = nums2.length - p2; // trick，让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 nums1 if (len1 &gt; len2) &#123; return getKth(nums2, p2, nums1, p1, k); &#125; if (len1 == 0) &#123; return nums2[p2 + k - 1]; &#125; if (k == 1) &#123; return Math.min(nums1[p1], nums2[p2]); &#125; int i = p1 + Math.min(len1, k / 2) - 1; int j = p2 + Math.min(len2, k / 2) - 1; if (nums1[i] &gt; nums2[j]) &#123; return getKth(nums1, p1, nums2, j + 1, k - (j - p2 + 1)); &#125; else &#123; return getKth(nums1, i + 1, nums2, p2, k - (i - p1 + 1)); &#125; &#125;&#125; 时间复杂度：$O(\log (m+n))$ 空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，空间复杂度为 $O(1)$ 总结自己思考的时候只想到了前两种解法，期间还使用快排的变式快速选择写过一个解法，然而翻书的时候才发现，快速选择的时间复杂度是 $O(N)$ ，况且对于已经排好序的两个数组来说，并没有前两种解法的效率高，看书的时候就记住了一个找第 k 大的元素用快速选择，生搬硬套。自己没有想到第三种解法，看了别人的题解才理解，说明对二分法的使用不太敏感。还是做题不够，认识不够，思考不够。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
