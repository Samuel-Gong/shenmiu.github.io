---
title: LeetCode-4-寻找两个有序数组的中位数
author: Shenmiu
date: 2019-07-24 00:26:34
categories:
- LeetCode
tags:
- Algorithm
urlname: median-of-two-sorted-arrays
mathjax: true
---
## 题目

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(\log(m + n))$。

<!-- more -->

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

```
nums1 = [1, 3]
nums2 = [2]
则中位数是 2.0
```

示例 2:

```
nums1 = [1, 2]
nums2 = [3, 4]
则中位数是 (2 + 3)/2 = 2.5
```

## 解法一

### 思路

因为是找两个有序数组的中位数，首先想到的就是合并两个数组再找中位数，而合并两个有序数组又是归并排序的一部分，自然而然就想到修改归并排序中的 merge 方法来进行解题。

### 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int p1 = 0;
        int p2 = 0;
        int len1 = nums1.length;
        int len2 = nums2.length;
        int[] all = new int[len1 + len2];
        int k = 0;
        while (p1 < len1 && p2 < len2) {
            if (nums1[p1] <= nums2[p2]) {
                all[k++] = nums1[p1++];
            } else {
                all[k++] = nums2[p2++];
            }
        }

        while (p1 < len1) {
            all[k++] = nums1[p1++];
        }
        while (p2 < len2) {
            all[k++] = nums2[p2++];
        }

        int len = all.length;
        if (len % 2 != 0) {
            return all[len / 2];
        } else {
            return (all[len / 2] + all[len / 2 - 1]) / 2.0;
        }
    }
}
```

时间复杂度：遍历全部数组 $O(m+n)$

空间复杂度：开辟了一个数组，保存合并后的两个数组 $O(m+n)$

## 解法二

### 思路

仔细思考，其实并没有必要归并两个数组，找到中位数即可终止循环，可以省去中位数之后对数组访问以及比较的开销。假设两个数组总长度为 len，对于奇数来说，找到第 $\lceil len/2 \rceil$ 个数即可停止，需要循环 $\lfloor len/2 \rfloor+1$ 次；对于偶数来说，需要找到第 $len/2$ 和第 $len/2+1$ 个数字，需要循环 $len/2+1$ 次。综合奇偶的情况，循环的次数是相同的，只是对于偶数来说，需要用一个变量来存储上一次循环中的所访问的元素，最后根据奇偶情况返回结果。

### 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int p1 = 0;
        int p2 = 0;
        int len1 = nums1.length;
        int len2 = nums2.length;
        int len = len1 + len2;
        int left = -1;
        int right = -1;
        for (int i = 0; i <= len / 2; i++) {
            left = right;
            // 两个数组都未耗尽
            if (p1 != len1 && p2 != len2) {
                if (nums1[p1] < nums2[p2]) {
                    right = nums1[p1++];
                } else {
                    right = nums2[p2++];
                }
            } else if (p1 == len1) { // 左数组耗尽
                right = nums2[p2++];
            } else { // 右数组耗尽
                right = nums1[p1++];
            }
        }

        if ((len & 1) != 0) { // 和 1 做位运算，判断奇偶
            return right;
        } else {
            return (left + right) / 2.0;
        }
    }
}
```
时间复杂度：遍历一半长度的数组 O(m+n)

空间复杂度：只保存部分常量 O(1)


## 解法三

### 思路

以上两种解法都还没有达到题目的要求，时间复杂度要达到 $O(\log(m+n))$ 的要求，通常来说需要用到二分法，需要思考的即是在此处如何使用二分法。以奇数为例，要找中位数，假设第 $k$ 小的数字是中位数，两个数组通过比较两个数组处于 $k/2$ 位置元素的大小，即可将较小元素及该数组内之前所有 $k/2$ 个元素都舍弃，这些元素必然不会处在中位数的位置。分析如下：

对于`A[0]`，`A[1]`…，`A[k/2]`，…；`B[0]`，`B[1]`…，`B[k/2]`，...，若 `A[k/2]` < `B[k/2]`，则 `A[k/2]` 最大只能是第 $k-1$ 小的数，当 $A[k/2] > B[k/2-1]$ 时成立。

下面通过图例展示下解法的过程。假设两个数组分别是 `A = [1, 3, 5, 7]`，`B = [1, 2, 3, 4, 5, 6, 7, 8, 9]`

两个数组元素个数为 13，中位数为第 7 个元素，两个数组的第 $k/2$ 个元素分别是 `A[2]`， `B[2]`，`B[2] < A[2]`，即 `A[2]` 及其之前的元素全部舍弃。

{% asset_img 4-1.png %}

橙色部分表示已经去掉的数字，第一次比较会排除 `B[0]、B[1]、B[2]` 三个元素，在剩下的元素中，只需要找到第 $k=7-3=4$ 小的数即可，再继续向后比较第 $k/2=2$ 个元素。

{% asset_img 4-2.png %}

这次比较将`A[0]、A[1]`元素去除。更新 $k=4-2=2$，向后比较第 $k/2=1$ 个元素

{% asset_img 4-3.png %}

这次比较将 `B[3]` 元素去除。更新 `k=2-1=1`，表示在剩余的元素中取第 1 小的元素，只需比较两个数组剩余元素的第一个元素的大小即可，较小的元素就是中位数。

{% asset_img 4-4.png %}


存在一种特殊情况，即 $k/2$ 大于某个数组的长度，如图，`k/2 > A.length`，则指针指向数组的末尾，使用数组末尾的元素进行比较。

{% asset_img 4-5.png %}

更新 $k=6-2=4$ ，此时上边的数组已经没有剩余元素了，可以直接返回`B[3]`作为结果。

{% asset_img 4-6.png %}

实际上`更新的 k 值 = 原 k 值 - 上次丢弃元素的数量`，丢弃的元素数量要根据具体情况进行判断。

我本身实现了一种非递归的方法，但是由于需要在循环内以及循环外对各个边界情况以及奇偶进行判断，造成代码臃肿不够简洁。LeetCode 题解中有一个人用了递归的方法进行解决，将奇数和偶数的情况进行合并计算，递归的终止条件有两个：某一数组无剩余元素，返回另一数组剩余的第一个元素； `k == 1`，返回两个数组中较小的元素。

### 代码

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int left = (n + m + 1) / 2;
        int right = (n + m + 2) / 2;
        // 将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。
        return (getKth(nums1, 0, nums2, 0, left) + getKth(nums1, 0, nums2, 0, right)) * 0.5;
    }

    private int getKth(int[] nums1, int p1, int[] nums2, int p2, int k) {
        int len1 = nums1.length - p1;
        int len2 = nums2.length - p2;
        // trick，让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 nums1
        if (len1 > len2) {
            return getKth(nums2, p2, nums1, p1, k);
        }
        if (len1 == 0) {
            return nums2[p2 + k - 1];
        }

        if (k == 1) {
            return Math.min(nums1[p1], nums2[p2]);
        }

        int i = p1 + Math.min(len1, k / 2) - 1;
        int j = p2 + Math.min(len2, k / 2) - 1;

        if (nums1[i] > nums2[j]) {
            return getKth(nums1, p1, nums2, j + 1, k - (j - p2 + 1));
        } else {
            return getKth(nums1, i + 1, nums2, p2, k - (i - p1 + 1));
        }
    }
}
```

时间复杂度：$O(\log (m+n))$

空间复杂度：虽然我们用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，空间复杂度为 $O(1)$

## 总结

自己思考的时候只想到了前两种解法，期间还使用快排的变式快速选择写过一个解法，然而翻书的时候才发现，快速选择的时间复杂度是 $O(N)$ ，况且对于已经排好序的两个数组来说，并没有前两种解法的效率高，看书的时候就记住了一个找第  `k` 大的元素用快速选择，生搬硬套。自己没有想到第三种解法，看了别人的题解才理解，说明对二分法的使用不太敏感。还是做题不够，认识不够，思考不够。
