---
title: 高级算法第一次练习
author: Shenmiu
date: 2019-09-29 09:50:08
categories:
- advanced-algorithm
tags:
- Algorithm
urlname: practice-1
mathjax: true
---

第一次高级算法课的课堂练习题解题思路及实现总结。

<!-- more -->

## 1. 按数值个数排序

### 描述

Given an array of integers, sort the array according to frequency of elements. For example, if the input array is {2, 3, 2, 4, 5, 12, 2, 3, 3, 3, 12}, then modify the array to {3, 3, 3, 3, 2, 2, 2, 12, 12, 4, 5}. If frequencies of two elements are same, print them in increasing order.

### 思路

可以将每个数字本身和它的出现次数构造为一个整体元素。这些元素排序的规则为，先按出现次数从大到小排序，若出现次数相同，则按照数字大小从小到大排序。

时间复杂度 $O(nlogn)$

空间复杂度 $O(n)$

### 实现

```java
private static String sort(int[] nums) {
    // key 是 num，value 是 freq
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(nums[i])) {
            int v = map.get(nums[i]);
            map.put(nums[i], ++v);
        } else {
            map.put(nums[i], 1);
        }
    }

    List<Node> nodes = new ArrayList<>();
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        nodes.add(new Node(entry.getKey(), entry.getValue()));
    }
    nodes.sort((o1, o2) -> {
        if (o1.f < o2.f) {
            return 1;
        } else if (o1.f > o2.f) {
            return -1;
        } else {
            return o1.v - o2.v;
        }
    });

    StringBuilder sb = new StringBuilder();
    for (Node n : nodes) {
        for (int i = 0; i < n.f; i++) {
            sb.append(n.v + " ");
        }
    }
    sb.deleteCharAt(sb.length() - 1);

    return sb.toString();
}

static class Node {
    int v;
    int f;

    public Node(int v, int f) {
        this.v = v;
        this.f = f;
    }
}
```



## 2. 最小交换次数

### 描述

Given an array of N distinct elementsA[ ], find the minimum number of swaps required to sort the array.Your are required to complete the function which returns an integer denoting the minimum number of swaps, required to sort the array.

### 思路

使用一个复制 A[] 的辅助数组，将辅助数组排序，得到原数组中每个元素在排序后应该在的位置，**使用 Map 保存每个元素和其最终位置的映射**。从前向后遍历原数组，与排序好的辅助数组比较。假设辅助数组为 aux，当前位置为 i

-   若 A[i] = aux[i]，则表示当前元素在排序后的最终位置上，则检查下一个元素
-   若 A[i] != aux[i]，将该元素和它正确位置的元素进行交换，swap(i, map.get(A[i]))，直到 A[i] = aux[i]

### 实现

```java
private static int miniSwap(int[] nums) {
    int[] aux = Arrays.copyOf(nums, nums.length);
    Arrays.sort(aux);
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < aux.length; i++) {
        map.put(aux[i], i);
    }

    int count = 0;
    for (int i = 0; i < nums.length; ) {
        if (nums[i] == aux[i]) {
            i++;
            continue;
        }
        swap(nums, i, map.get(nums[i]));
        count++;
    }
    return count;
}
```



## 3. 倒置个数

### 描述

有一个由 N 个实数构成的数组，如果一对元素 A[i] 和 A[j] 是倒序的，即 i < j 但是 A[i] > A[j] 则称它们是一个倒置，设计一个计算该数组中所有倒置数量的算法。要求算法复杂度为 $O(nlogn)$

### 思路

这是一道典型的归并排序的应用题，假设一个左右被排序好的两个部分，aux[lo, ... , mid] 和 aux[mid+1, ... , hi]，思考如何在归并两个部分的时候进行倒置的计算。

指针 i 指向 aux[lo, ... , mid] 中的元素

指针 j 指向 aux[mid+1, ... , hi] 中的元素

对两个部分按照正常归并排序进行排序，需要注意的是计算倒置的时机：

-   当 aux[i] > aux[j] 时，形成了倒置，且 aux[i, ... , mid] 之间的所有数和 aux[j] 都形成了倒置对，此时倒置个数为 **mid - i + 1**

### 实现

```java
private static int[] aux;

public static int sort(int[] a) {
    aux = new int[a.length];
    return sort(a, 0, a.length - 1);
}

private static int sort(int[] a, int lo, int hi) {
    if (hi <= lo) {
        return 0;
    }
    int mid = lo + (hi - lo) / 2;
    int count = 0;
    count += sort(a, lo, mid);
    count += sort(a, mid + 1, hi);
    return count + merge(a, lo, mid, hi);
}

private static int merge(int[] a, int lo, int mid, int hi) {
    for (int k = lo; k <= hi; k++) {
        aux[k] = a[k];
    }

    int count = 0;

    int i = lo, j = mid + 1;
    for (int k = lo; k <= hi; k++) {
        if (i > mid) {
            a[k] = aux[j++];
        } else if (j > hi) {
            a[k] = aux[i++];
        } else if (aux[j] < aux[i]) {
            count += mid - i + 1;
            a[k] = aux[j++];
        } else {
            a[k] = aux[i++];
        }
    }
    return count;
}
```



## 4. 相对排序

### 描述

Given two array A1[] and A2[], sort A1 in such a way that the relative order among the elements will be same as those in A2. For the elements not present in A2. Append them at last in sorted order. It is also given that the number of elements in A2[] are smaller than or equal to number of elements in A1[] and A2[] has all distinct elements.

Input:A1[] = {2, 1, 2, 5, 7, 1, 9, 3, 6, 8, 8} A2[] = {2, 1, 8, 3} Output: A1[] = {2, 2, 1, 1, 8, 8, 3, 5, 6, 7, 9}

Since 2 is present first in A2[], all occurrences of 2s should appear first in A[], then all occurrences 1s as 1 comes after 2 in A[]. Next all occurrences of 8 and then all occurrences of 3. Finally we print all those elements of A1[] that are not present in A2[]

### 思路

和第一题思路一样，同样是按照给定规则给数组排序，将数组中的数、数的出现次数以及在 A2 中的出现顺序作为一个元素，对这些元素进行排序，最后输出结果。

排序规则为：

-   先按 A2 中的出现先后顺序从小到大排序。若 A2[i] = n，则 n 的 order 为 i。若数字没出现在 A2[] 中，则 order 为 Integer.MAX_VALUE。
-   再按数字大小从小到大排序。

### 实现

```java
private static String sort(int[] nums, int[] orders) {
    Map<Integer, Integer> orderMap = new HashMap<>();
    for (int i = 0; i < orders.length; i++) {
        orderMap.put(orders[i], i);
    }

    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(nums[i])) {
            int v = map.get(nums[i]);
            map.put(nums[i], ++v);
        } else {
            map.put(nums[i], 1);
        }
    }

    List<Node> nodes = new ArrayList<>();
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        int order = Integer.MAX_VALUE;
        if (orderMap.containsKey(entry.getKey())) {
            order = orderMap.get(entry.getKey());
        }
        nodes.add(new Node(entry.getKey(), entry.getValue(), order));
    }
    nodes.sort((o1, o2) -> {
        if (o1.o > o2.o) {
            return 1;
        } else if (o1.o < o2.o) {
            return -1;
        } else {
            return o1.v - o2.v;
        }
    });

    StringBuilder sb = new StringBuilder();
    for (Node n : nodes) {
        for (int i = 0; i < n.f; i++) {
            sb.append(n.v + " ");
        }
    }
    sb.deleteCharAt(sb.length() - 1);

    return sb.toString();
}

static class Node {
    int v;
    int f;
    int o;

    public Node(int v, int f, int o) {
        this.v = v;
        this.f = f;
        this.o = o;
    }
}
```



